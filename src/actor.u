module Actor
  behavior gen_server

  def self.start(module_name)
    {:ok, pid} = gen_server::start(__name__, [module_name], [])
    {pid: pid}
  end

  def self.start_link(module_name)
    {:ok, pid} = gen_server::start_link(__name__, [module_name], [])
    {pid: pid}
  end

  def self.init([module_name])
    {:ok, [module_name]}
  end

  def self.handle_call({receiver, method_name, args}, _from, state)
    {:object, module_name, _} = receiver
    reply_value = apply(module_name, method_name, [receiver, *args])
    {:reply, reply_value, state}
  end

  def self.handle_cast({receiver, method_name, args}, state)
    {:object, module_name, _} = receiver
    apply(module_name, method_name, [receiver, *args])
    {:noreply, state}
  end

  def self.handle_info(message, state)
    {:noreply, state}
  end

  def self.terminate(reason, state)
    [module_name] = state
    {:object, module_name, {}}.__terminate__(reason)
  end

  def self.code_change(old_version, state, extra)
    {:ok, state}
  end

  def stop()
    gen_server::stop(@pid)
  end

  def stop(reason, timeout)
    gen_server::stop(@pid, reason, timeout)
  end

  def call(method_name, args)
    gen_server::call(@pid, {self, method_name, args})
  end

  def call(method_name, args, timeout)
    gen_server::call(@pid, {self, method_name, args}, timeout)
  end

  def send(method_name, args)
    gen_server::cast(@pid, {self, method_name, args})
  end

  def attr(name, value)
    erlang::put(name, value)
    value
  end

  def attr(name)
    erlang::get(name)
  end

  def initialize()
    {:object, module_name, _} = self
    new ActorWrapper({:object,
                      module_name,
                      Actor::start(module_name)})
  end

  def __terminate__(reason)
    :ok
  end
end