module uiro_runtime

  record object
    __class__,
    __state__
  end

  def self.call_method(obj, method_name, args) if is_atom(obj)
    call_target_method(:uiro_atom, obj, method_name, args)
  end

  def self.call_method(obj, method_name, args) if is_list(obj)
    call_target_method(:uiro_list, obj, method_name, args)
  end

  def self.call_method(obj, method_name, args) if is_integer(obj)
    call_target_method(:uiro_integer, obj, method_name, args)
  end

  def self.call_method(obj, method_name, args) if is_float(obj)
    call_target_method(:uiro_float, obj, method_name, args)
  end

  def self.call_method(obj, method_name, args) if is_binary(obj)
    call_target_method(:uiro_binary, obj, method_name, args)
  end

  def self.call_method(obj, method_name, args) if is_function(obj)
    call_target_method(:uiro_function, obj, method_name, args)
  end

  def self.call_method(obj, method_name, args) if is_pid(obj)
    call_target_method(:uiro_pid, obj, method_name, args)
  end

  def self.call_method(%object(__class__ = module_name, __state__ = state), method_name, args)
    obj = %object(__class__ = module_name, __state__ = state)
    exports = apply(module_name, :module_info, [:exports])
    if lists::keyfind(method_name, 1, exports)
      apply(module_name, method_name, [obj, *args])
    else
      call_parent_method(module_name, obj, method_name, args)
    end
  end

  def self.call_method(obj, method_name, args) if is_map(obj)
    call_target_method(:uiro_map, obj, method_name, args)
  end

  def self.call_method(obj, method_name, args) if is_tuple(obj)
    call_target_method(:uiro_tuple, obj, method_name, args)
  end

  def self.call_target_method(module_name, obj, method_name, args)
    exports = apply(module_name, :module_info, [:exports])
    if lists::keyfind(method_name, 1, exports)
      apply(module_name, method_name, [obj, *args])
    else
      call_parent_method(module_name, obj, method_name, args)
    end
  end

  def self.list_modules_([head, *tail], acc)
    list_modules_(tail, acc ++ [head] ++ list_modules(head))
  end

  def self.list_modules_([], acc)
    acc
  end

  def self.list_modules(module_name)
    attributes = apply(module_name, :module_info, [:attributes])
    match lists::keyfind(:include, 1, attributes)
      case :false
        []
      case {:include, :false}
        []
      case {:include, include_mods}
        list_modules_(include_mods, [])
    end
  end

  def self.call_parent_method(module_name, obj, method_name, args)
    include_mods = list_modules(module_name) ++ [:Kernel]
    target_mod = find_mod({method_name, length(args) + 1}, include_mods)
    if target_mod == false
      apply(module_name, :method_missing, [obj, method_name, args])
    else
      apply(target_mod, method_name, [obj, *args])
    end
  end

  def self.find_mod(method, [])
    false
  end

  def self.find_mod(method, [mod, *tl])
    exports = apply(mod, :module_info, [:exports])
    if index_of(method, exports)
      mod
    else
      find_mod(method, tl)
    end
  end

  def self.index_of(item, list)
    index_of(item, list, 1)
  end

  def self.index_of(_, [], _)
    false
  end

  def self.index_of(item, [item, *_], index)
    index
  end

  def self.index_of(item, [_, *tl], index)
    index_of(item, tl, index + 1)
  end

  def self.new_object(module_name, args)
    obj = call_method(%object(__class__ = module_name,
                              __state__ = {}),
                      :initialize,
                      args)
    match obj
      case %object()
        obj
      case _
        %object(__class__ = module_name,
                __state__ = obj)
    end
  end
end